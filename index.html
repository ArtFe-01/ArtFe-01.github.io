<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hexa-Political Compass</title>
  <meta name="description" content="Hexa-Political Compass — coordinate-based politico-ideological classification." />
  <style>
    :root{
      --bg:#0b0e14; --panel:#0f1522; --panel2:#111a2b; --text:#e9eefc; --muted:#a7b1c7;
      --line:rgba(255,255,255,.10); --line2:rgba(255,255,255,.06);
      --btn:#1f2a44; --btn2:#233155; --accent:#7c9cff; --good:#44ef9a; --bad:#ff5a73;
      --warn:#ffc14d;
      --brown:#8b5a2b; --blue:#3b82f6; --purple:#8b5cf6; --green:#22c55e; --red:#ef4444; --redbrown:#b45309; --grey:#6b7280;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    html, body{ color-scheme: dark; } /* helps native controls render dark on many browsers/OS */

    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif;
      background:radial-gradient(1200px 700px at 15% 5%, rgba(124,156,255,.12), transparent 55%),
                 radial-gradient(900px 700px at 85% 25%, rgba(34,197,94,.10), transparent 60%),
                 radial-gradient(900px 900px at 70% 90%, rgba(239,68,68,.08), transparent 60%),
                 var(--bg);
      color:var(--text);
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
      background:rgba(11,14,20,.55);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1150px; margin:0 auto; padding:16px}
    .nav{display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:space-between;}
    .brand{display:flex; align-items:center; gap:10px}
    .logo{
      width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, rgba(124,156,255,.9), rgba(34,197,94,.75));
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    .brand h1{font-size:16px; margin:0}
    .brand .sub{font-size:12px; color:var(--muted); margin-top:2px}
    .links{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .pill{
      padding:8px 10px; border:1px solid var(--line); border-radius:999px;
      background:rgba(255,255,255,.03);
      font-size:13px; color:var(--text);
      display:inline-flex; gap:8px; align-items:center;
    }
    .pill:hover{background:rgba(255,255,255,.06)}
    .pill.primary{border-color:rgba(124,156,255,.35); background:rgba(124,156,255,.10)}
    .pill.danger{border-color:rgba(255,90,115,.35); background:rgba(255,90,115,.10)}
    .pill.good{border-color:rgba(68,239,154,.35); background:rgba(68,239,154,.10)}
    .pill.warn{border-color:rgba(255,193,77,.35); background:rgba(255,193,77,.10)}
    .rightMeta{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .userTag{
      padding:7px 10px; border-radius:999px;
      border:1px solid var(--line2); background:rgba(255,255,255,.02);
      font-size:12px; color:var(--muted);
    }
    main{padding:18px 0 80px}
    .grid{display:grid; gap:14px}
    @media(min-width:980px){
      .grid.cols2{grid-template-columns: 1.1fr .9fr}
      .grid.cols3{grid-template-columns: 1fr 1fr 1fr}
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--line);
      border-radius:18px;
      padding:14px;
      box-shadow:0 22px 70px rgba(0,0,0,.30);
    }
    .card h2{margin:0 0 8px; font-size:16px}
    .muted{color:var(--muted)}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .spacer{height:10px}
    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:13px;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn.primary{border-color:rgba(124,156,255,.35); background:rgba(124,156,255,.12)}
    .btn.good{border-color:rgba(68,239,154,.35); background:rgba(68,239,154,.12)}
    .btn.danger{border-color:rgba(255,90,115,.35); background:rgba(255,90,115,.12)}
    .btn.warn{border-color:rgba(255,193,77,.35); background:rgba(255,193,77,.10)}
    .btn.small{padding:7px 9px; font-size:12px; border-radius:10px}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    input,select,textarea{
      width:100%;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
      font-size:13px;
    }
    /* Fix: on some PCs the dropdown list renders with a light system background, so force option colors */
    select option, select optgroup{
      background: var(--panel);
      color: var(--text);
    }

    textarea{min-height:90px; resize:vertical}
    label{font-size:12px; color:var(--muted)}
    .kpi{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .kpi .box{border:1px solid var(--line2); background:rgba(255,255,255,.02); border-radius:14px; padding:10px;}
    .kpi .box .t{font-size:11px; color:var(--muted)}
    .kpi .box .v{font-size:16px; margin-top:6px}
    .hr{border-top:1px solid var(--line2); margin:12px 0}
    .list{display:flex; flex-direction:column; gap:10px}
    .item{border:1px solid var(--line2); background:rgba(255,255,255,.02); border-radius:14px; padding:10px;}
    .item .top{display:flex; align-items:flex-start; justify-content:space-between; gap:10px}
    .item .title{font-size:13px; margin:0}
    .item .meta{font-size:12px; color:var(--muted)}
    .badge{
      font-size:11px; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line2);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      display:inline-flex; gap:6px; align-items:center;
    }
    .badge.good{border-color:rgba(68,239,154,.25); background:rgba(68,239,154,.10); color:#bfffe0}
    .badge.warn{border-color:rgba(255,193,77,.25); background:rgba(255,193,77,.10); color:#ffe0a8}
    .badge.bad{border-color:rgba(255,90,115,.25); background:rgba(255,90,115,.10); color:#ffd0d7}
    .badge.primary{border-color:rgba(124,156,255,.25); background:rgba(124,156,255,.10); color:#d7e2ff}
    .table{
      width:100%; border-collapse:separate; border-spacing:0;
      overflow:hidden; border-radius:14px;
      border:1px solid var(--line2);
      background:rgba(255,255,255,.02);
    }
    .table th,.table td{padding:10px 10px; font-size:12px; border-bottom:1px solid var(--line2); vertical-align:top;}
    .table th{color:var(--muted); font-weight:600; text-align:left; background:rgba(255,255,255,.02)}
    .table tr:last-child td{border-bottom:none}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .canvasWrap{display:flex; justify-content:center}
    canvas{max-width:100%; background:rgba(0,0,0,.18); border:1px solid var(--line); border-radius:18px}
    .smallnote{font-size:12px; color:var(--muted); line-height:1.35}
    .toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(15,21,34,.9); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px;
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      color:var(--text); font-size:13px;
      display:none;
      max-width:min(92vw, 700px);
    }
    .split{display:grid; gap:14px;}
    @media(min-width:980px){ .split{grid-template-columns:1fr 1fr} }
    .chips{display:flex; flex-wrap:wrap; gap:6px}
    .chip{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--line2); background:rgba(255,255,255,.02); color:var(--muted);}
    .dangerText{color:#ff9aaa}
    .goodText{color:#b7ffd8}
    .warnText{color:#ffe0a8}

    /* ===== Answer picker (radio chips) ===== */
    .choiceGrid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap:8px;
    }
    .choice{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:9px 10px;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .choice:hover{background:rgba(255,255,255,.06)}
    .choice input{display:none}
    .choice.active{
      border-color:rgba(124,156,255,.45);
      background:rgba(124,156,255,.14);
    }
    .choice .k{
      font-size:11px;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid var(--line2);
      color:var(--muted);
      flex:0 0 auto;
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="nav">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Hexa-Political Compass</h1>
          <div class="sub">A hexagonal alternative to classical Political Compass</div>
        </div>
      </div>

      <div class="links">
        <a class="pill" href="#/">Home</a>
        <a class="pill primary" href="#/quiz">Take Test</a>
        <a class="pill" href="#/ledger">Result Ledger</a>
        <a class="pill" href="#/suggest">Suggest Questions</a>
        <a class="pill" href="#/compare">Compare</a>
        <a id="adminLink" class="pill warn" href="#/admin" style="display:none;">Admin</a>
      </div>

      <div class="rightMeta">
        <span id="userTag" class="userTag">Connecting…</span>
        <button id="authBtn" class="pill good" type="button">Sign in / Upgrade</button>
        <button id="signOutBtn" class="pill danger" type="button" style="display:none;">Sign out</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div id="app"></div>
  </div>
</main>

<div id="toast" class="toast"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import {
    getAuth, onAuthStateChanged,
    signInWithEmailAndPassword, createUserWithEmailAndPassword,
    signOut, updateProfile, signInAnonymously,
    EmailAuthProvider, linkWithCredential
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, addDoc, deleteDoc,
    collection, query, where, orderBy, limit, getDocs,
    serverTimestamp, runTransaction, increment
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

  // ---- Firebase config (yours) ----
  const firebaseConfig = {
    apiKey: "AIzaSyAtVzsSQpngelRO3Yn49cKPzGgU0jtqRfk",
    authDomain: "hexa-political-compass.firebaseapp.com",
    projectId: "hexa-political-compass",
    storageBucket: "hexa-political-compass.firebasestorage.app",
    messagingSenderId: "1055196691338",
    appId: "1:1055196691338:web:b25959417b5a7099eb2673",
    measurementId: "G-PVBZBEDRK8"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ============================
  // MODEL (ROTATED / ADJUSTED)
  // ============================
  // Requirement:
  // Third-Position is the corner between Red-Brown & Brown and is at 12:00 (top).
  // Corners (clockwise) are:
  // Third-Position -> Reactionary -> Right-wing -> Centrist -> Left-wing -> Syncretic -> back to Third.
  //
  // Coordinate convention:
  // angle 0° = right, 90° = up (canvas uses cy - sin(a)*R).
  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
  function rad(deg){ return deg * Math.PI / 180; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function to360(deg){ let d = deg % 360; if(d < 0) d += 360; return d; }

  // Poles are CORNERS (vertices).
  const POLES = [
    { key:"THIRD",       name:"Third-Position Politics", angle360:  90 },
    { key:"REACTIONARY", name:"Reactionary Politics",    angle360:  30 },
    { key:"RIGHT",       name:"Right-wing Politics",     angle360: 330 },
    { key:"CENTRIST",    name:"Centrist Politics",       angle360: 270 },
    { key:"LEFT",        name:"Left-wing Politics",      angle360: 210 },
    { key:"SYNCRETIC",   name:"Syncretic Politics",      angle360: 150 },
  ];

  // Colour sectors are the FILTER wedges between adjacent corners.
  // Their centers are mid-angles of adjacent corners:
  // Brown(60), Blue(0), Purple(300), Green(240), Red(180), Red-Brown(120).
  const SECTORS = [
    { key:"BROWN",    colorName:"Brown",     name:"Para-Fascism",            color:getCSS("--brown"),    angleDeg:  60 },
    { key:"BLUE",     colorName:"Blue",      name:"Statist Right",          color:getCSS("--blue"),     angleDeg:   0 },
    { key:"PURPLE",   colorName:"Purple",    name:"Libertarian Right",      color:getCSS("--purple"),   angleDeg: 300 },
    { key:"GREEN",    colorName:"Green",     name:"Libertarian Left",       color:getCSS("--green"),    angleDeg: 240 },
    { key:"RED",      colorName:"Red",       name:"Statist Left",           color:getCSS("--red"),      angleDeg: 180 },
    { key:"REDBROWN", colorName:"Red-Brown", name:"Intransigent Fascism",   color:getCSS("--redbrown"), angleDeg: 120 },
  ];

  const GREY = { key:"GREY", name:"Grey (Center)", color:getCSS("--grey") };

  // Sector ranges in [0,360), defined by corner/pole boundaries.
  // IMPORTANT: Blue wraps (330 -> 30).
  const SECTOR_RANGES = [
    // Blue: between RIGHT(330) and REACTIONARY(30)
    { sectorKey:"BLUE", start:330, end:30, startPole:"RIGHT", endPole:"REACTIONARY",
      sliceNearStart:"Formal Right", sliceNearEnd:"Reactionary-Right" },

    // Brown: between REACTIONARY(30) and THIRD(90)
    { sectorKey:"BROWN", start:30, end:90, startPole:"REACTIONARY", endPole:"THIRD",
      sliceNearStart:"Reactionary Partner", sliceNearEnd:"Third-Position Right" },

    // Red-Brown: between THIRD(90) and SYNCRETIC(150)
    { sectorKey:"REDBROWN", start:90, end:150, startPole:"THIRD", endPole:"SYNCRETIC",
      sliceNearStart:"Third-Position Partner", sliceNearEnd:"Syncretic Partner" },

    // Red: between SYNCRETIC(150) and LEFT(210)
    { sectorKey:"RED", start:150, end:210, startPole:"SYNCRETIC", endPole:"LEFT",
      sliceNearStart:"Syncretic-Left", sliceNearEnd:"Formal Left" },

    // Green: between LEFT(210) and CENTRIST(270)
    { sectorKey:"GREEN", start:210, end:270, startPole:"LEFT", endPole:"CENTRIST",
      sliceNearStart:"Formal Left", sliceNearEnd:"Centrist-Left" },

    // Purple: between CENTRIST(270) and RIGHT(330)
    { sectorKey:"PURPLE", start:270, end:330, startPole:"CENTRIST", endPole:"RIGHT",
      sliceNearStart:"Centrist-Right", sliceNearEnd:"Formal Right" },
  ];

  // For drawing: corner order clockwise (starting at top = Third-Position).
  const POLE_ORDER_CLOCKWISE = ["THIRD","REACTIONARY","RIGHT","CENTRIST","LEFT","SYNCRETIC"];

  // For drawing: edge -> sector mapping (between adjacent corners, clockwise).
  const EDGE_SECTORS_CLOCKWISE = [
    { sectorKey:"BROWN",    poleA:"THIRD",       poleB:"REACTIONARY" },
    { sectorKey:"BLUE",     poleA:"REACTIONARY", poleB:"RIGHT" },
    { sectorKey:"PURPLE",   poleA:"RIGHT",       poleB:"CENTRIST" },
    { sectorKey:"GREEN",    poleA:"CENTRIST",    poleB:"LEFT" },
    { sectorKey:"RED",      poleA:"LEFT",        poleB:"SYNCRETIC" },
    { sectorKey:"REDBROWN", poleA:"SYNCRETIC",   poleB:"THIRD" },
  ];

  // ---- Default scoring settings (admin can override in Firestore) ----
  const DEFAULT_SETTINGS = {
    answerScale: [
      { key:"SD", label:"Strongly Disagree", value:-1.0 },
      { key:"D",  label:"Disagree",          value:-0.8 },
      { key:"MD", label:"Mildly Disagree",   value:-0.6 },
      { key:"LD", label:"Lean Disagree",     value:-0.3 },

      { key:"N",  label:"Neutral",           value: 0.0, special:"neutral" },
      { key:"A",  label:"Ambivalent",        value: 0.0, special:"ambivalent" },
      { key:"NA", label:"Non-Applicable",    value: 0.0, special:"na" },

      { key:"LA", label:"Lean Agree",        value: 0.3 },
      { key:"MA", label:"Mildly Agree",      value: 0.6 },
      { key:"AG", label:"Agree",             value: 0.8 },
      { key:"SA", label:"Strongly Agree",    value: 1.0 },
    ],
    importanceScale: [
      { key:1, label:"Low importance",     mult:0.6 },
      { key:2, label:"Somewhat important", mult:0.85 },
      { key:3, label:"Important",          mult:1.0 },
      { key:4, label:"Very important",     mult:1.15 },
      { key:5, label:"Core / defining",    mult:1.3 },
    ],
    synergy: {
      enabled: true,
      neutralStrength: 0.35,
      ambivalentStrength: 0.20,
      threshold: 0.25,
    },
    centerRadius: 0.12,
    pureCornerRadius: 0.82,
    purePoleAngleToleranceDeg: 7,
  };

  const state = {
    user: null,
    isAdmin: false,
    settings: structuredClone(DEFAULT_SETTINGS),
    questions: [],
    lastAttempt: null,
  };

  // ---- UI helpers ----
  const $app = document.getElementById("app");
  const $toast = document.getElementById("toast");
  const $userTag = document.getElementById("userTag");
  const $authBtn = document.getElementById("authBtn");
  const $signOutBtn = document.getElementById("signOutBtn");
  const $adminLink = document.getElementById("adminLink");

  function toast(msg, ms=2600){
    $toast.textContent = msg;
    $toast.style.display = "block";
    clearTimeout(toast._t);
    toast._t = setTimeout(()=> $toast.style.display = "none", ms);
  }

  function htmlEscape(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;")
      .replaceAll(">","&gt;").replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function fmtTime(ts){
    if(!ts) return "";
    const d = ts instanceof Date ? ts : (ts.toDate ? ts.toDate() : new Date(ts));
    return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
  }

  function route(){
    const raw = location.hash.replace(/^#\/?/, "");
    const [pathPart, queryPart] = raw.split("?");
    const parts = (pathPart || "").split("/").filter(Boolean);
    const q = new URLSearchParams(queryPart || "");
    return { parts, q, raw };
  }
  function navTo(hash){ location.hash = hash; }

  function isGuest(){ return !!(state.user && state.user.isAnonymous); }

  // ---- Auth modal ----
  function showAuthModal(){
    const guestNote = isGuest()
      ? `<span class="badge warn">You are currently browsing as Guest</span>
         <div class="spacer"></div>
         <div class="smallnote muted">Upgrading links your Guest attempts to an email/password account.</div>`
      : `<div class="smallnote muted">If you don’t want an account, ignore this — Guest mode already works.</div>`;

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Sign in</h2>
          ${guestNote}
          <div class="spacer"></div>

          <label>Email</label>
          <input id="si_email" type="email" placeholder="you@example.com" autocomplete="email" />
          <div class="spacer"></div>
          <label>Password</label>
          <input id="si_pass" type="password" placeholder="••••••••" autocomplete="current-password" />
          <div class="spacer"></div>
          <button id="si_btn" class="btn good" type="button">Sign in</button>
          <button class="btn" type="button" onclick="location.hash='#/'">Cancel</button>

          <div class="spacer"></div>
          <div class="smallnote muted">
            If you want to keep Guest attempts, use “Register / Upgrade” instead.
          </div>
        </div>

        <div class="card">
          <h2>${isGuest() ? "Register / Upgrade Guest" : "Create account"}</h2>
          <label>Display name</label>
          <input id="su_name" type="text" placeholder="Username" autocomplete="name" />
          <div class="spacer"></div>
          <label>Email</label>
          <input id="su_email" type="email" placeholder="you@example.com" autocomplete="email" />
          <div class="spacer"></div>
          <label>Password</label>
          <input id="su_pass" type="password" placeholder="At least 6 characters" autocomplete="new-password" />
          <div class="spacer"></div>
          <button id="su_btn" class="btn primary" type="button">${isGuest() ? "Upgrade" : "Register"}</button>
          <div class="spacer"></div>
          <div class="smallnote muted">
            Admin status is controlled by Firestore doc: <span class="mono">admins/&lt;uid&gt;</span>.
          </div>
        </div>
      </div>
    `;

    document.getElementById("si_btn").onclick = async ()=>{
      const email = document.getElementById("si_email").value.trim();
      const pass = document.getElementById("si_pass").value;
      if(!email || !pass) return toast("Email + password required.");
      try{
        await signInWithEmailAndPassword(auth, email, pass);
        toast("Signed in.");
        navTo("#/");
      }catch(e){
        toast("Sign in failed: " + (e?.message || e));
      }
    };

    document.getElementById("su_btn").onclick = async ()=>{
      const name = document.getElementById("su_name").value.trim();
      const email = document.getElementById("su_email").value.trim();
      const pass = document.getElementById("su_pass").value;
      if(!email || !pass) return toast("Email + password required.");

      try{
        if(isGuest()){
          const cred = EmailAuthProvider.credential(email, pass);
          const linked = await linkWithCredential(auth.currentUser, cred);
          if(name) await updateProfile(linked.user, { displayName: name });
          await setDoc(doc(db, "users", linked.user.uid), {
            displayName: name || "",
            email,
            upgradedAt: serverTimestamp(),
            createdAt: serverTimestamp(),
          }, { merge:true });
          toast("Guest upgraded.");
        } else {
          const created = await createUserWithEmailAndPassword(auth, email, pass);
          if(name) await updateProfile(created.user, { displayName: name });
          await setDoc(doc(db, "users", created.user.uid), {
            displayName: name || "",
            email,
            createdAt: serverTimestamp(),
          }, { merge:true });
          toast("Account created.");
        }
        navTo("#/");
      }catch(e){
        toast("Register/upgrade failed: " + (e?.message || e));
      }
    };
  }

  $authBtn.onclick = ()=> navTo("#/login");
  $signOutBtn.onclick = async ()=>{
    try{
      await signOut(auth);
      toast("Signed out (switching back to Guest).");
      navTo("#/");
    }catch(e){
      toast("Sign out failed: " + (e?.message || e));
    }
  };

  // ---- Firestore helpers ----
  async function loadSettings(){
    try{
      const snap = await getDoc(doc(db, "settings", "scoring"));
      if(snap.exists()){
        const data = snap.data();
        state.settings = deepMerge(structuredClone(DEFAULT_SETTINGS), data);
      }else{
        state.settings = structuredClone(DEFAULT_SETTINGS);
      }
    }catch{
      state.settings = structuredClone(DEFAULT_SETTINGS);
    }
  }

    async function loadQuestions(){
  const qs = [];

  // Primary query (ordered). May require a composite index.
  try{
    const qref = query(
      collection(db, "questions"),
      where("enabled","==", true),
      orderBy("createdAt","asc"),
      limit(500)
    );
    const snap = await getDocs(qref);
    snap.forEach(d => qs.push({ id: d.id, ...d.data() }));
  }catch(e){
    console.error("loadQuestions primary query failed:", e);
    toast(`Questions query failed: ${e?.code || e?.message || e}`);

    // Fallback query: still filtered for guests, no orderBy (avoids composite index)
    try{
      const snap2 = await getDocs(query(
        collection(db, "questions"),
        where("enabled","==", true),
        limit(500)
      ));
      snap2.forEach(d => qs.push({ id: d.id, ...d.data() }));

      // Keep ordering stable
      qs.sort((a,b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
    }catch(e2){
      console.error("loadQuestions fallback query failed:", e2);
      toast(`Questions fallback failed: ${e2?.code || e2?.message || e2}`);
    }
  }

  state.questions = qs;
}
  
  async function checkAdmin(uid){
    if(!uid) return false;
    try{
      const snap = await getDoc(doc(db, "admins", uid));
      return snap.exists();
    }catch{
      return false;
    }
  }

  function deepMerge(base, patch){
    if(patch == null) return base;
    if(Array.isArray(base) && Array.isArray(patch)) return patch;
    if(typeof base !== "object" || typeof patch !== "object") return patch;
    const out = Array.isArray(base) ? [...base] : { ...base };
    for(const k of Object.keys(patch)){
      out[k] = deepMerge(base?.[k], patch[k]);
    }
    return out;
  }

  // ============================
  // SCORING
  // ============================
  function sectorVec(sectorKey){
    const s = SECTORS.find(x=>x.key===sectorKey);
    if(!s) return { x:0, y:0, angleDeg:0 };
    const a = rad(s.angleDeg);
    return { x: Math.cos(a), y: Math.sin(a), angleDeg: s.angleDeg };
  }
  function getAnswerDef(key){ return state.settings.answerScale.find(a=>a.key===key) || null; }
  function getImportanceDef(n){
    return state.settings.importanceScale.find(i=>Number(i.key)===Number(n)) || state.settings.importanceScale[2];
  }

  // ===== Pluri-direction support (hierarchical) + pole-name keys =====

  const POLE_COLORS = {
    THIRD:       getCSS("--redbrown"),
    REACTIONARY: getCSS("--brown"),
    RIGHT:       getCSS("--blue"),
    CENTRIST:    getCSS("--grey"),
    LEFT:        getCSS("--green"),
    SYNCRETIC:   getCSS("--red"),
  };

  function normalizeDirKey(rawKey){
    const k = String(rawKey || "").trim();
    if(!k) return "";
    const up = k.toUpperCase().replaceAll(" ", "").replaceAll("_","").replaceAll("-","");

    const alias = {
      RIGHTWING: "RIGHT",
      RIGHT: "RIGHT",
      CENTRIST: "CENTRIST",
      LEFTWING: "LEFT",
      LEFT: "LEFT",
      SYNCRETIC: "SYNCRETIC",
      REACTIONARY: "REACTIONARY",
      THIRDPOSITION: "THIRD",
      THIRD: "THIRD",

      BLUE: "BLUE",
      PURPLE: "PURPLE",
      GREEN: "GREEN",
      RED: "RED",
      REDBROWN: "REDBROWN",
      BROWN: "BROWN",

      GREY: "GREY",
      GRAY: "GREY",
    };

    return alias[up] || up;
  }

  function isValidDirKey(k){
    const kk = normalizeDirKey(k);
    if(!kk) return false;
    if(kk === "GREY") return true;
    return POLES.some(p => p.key === kk) || SECTORS.some(s => s.key === kk);
  }

  function dirVec(key){
    const kk = normalizeDirKey(key);

    const pole = POLES.find(p => p.key === kk);
    if(pole){
      const a = rad(pole.angle360);
      return { x: Math.cos(a), y: Math.sin(a) };
    }

    const sector = SECTORS.find(s => s.key === kk);
    if(sector){
      const a = rad(sector.angleDeg);
      return { x: Math.cos(a), y: Math.sin(a) };
    }

    return { x: 0, y: 0 };
  }

  function dirDisplay(key){
    const kk = normalizeDirKey(key);

    if(kk === "GREY"){
      return { label:"Grey (Center)", color:getCSS("--grey"), kind:"GREY", key:"GREY" };
    }

    const pole = POLES.find(p => p.key === kk);
    if(pole){
      return {
        label: pole.name.replace(" Politics",""),
        color: POLE_COLORS[kk] || getCSS("--accent"),
        kind: "POLE",
        key: kk
      };
    }

    const sector = SECTORS.find(s => s.key === kk);
    if(sector){
      return {
        label: `${sector.name} (${sector.colorName})`,
        color: sector.color,
        kind: "SECTOR",
        key: kk
      };
    }

    return { label: kk || "—", color:"#aaa", kind:"UNKNOWN", key: kk };
  }

  // Spec examples:
  // "Right-wing"
  // "Right-wing, Centrist, Left-wing"
  // "Right-wing:0.6, Centrist:0.4"
  // "Right-wing > Centrist > Left-wing"
  // Hierarchy rule if no explicit weight: 1, 0.5, 0.25, ...
  function parseDirectionSpec(spec){
    let s = String(spec || "").trim();
    if(!s) return [];
    s = s.replaceAll(">", ",");

    const tokens = s.split(",").map(x=>x.trim()).filter(Boolean);
    const parts = [];

    for(let i=0;i<tokens.length;i++){
      const tok = tokens[i];
      const [rawKey, rawW] = tok.split(":").map(z=>z.trim());
      const key = normalizeDirKey(rawKey);

      if(!isValidDirKey(key)) continue;

      let w;
      if(rawW == null || rawW === ""){
        w = Math.pow(0.5, i);
      }else{
        const num = Number(rawW);
        w = Number.isFinite(num) ? num : Math.pow(0.5, i);
      }
      if(Math.abs(w) <= 1e-9) continue;

      parts.push({ key, w });
    }
    return parts;
  }

  // Returns [{key,w}] from either:
  // - q.directions = [{key:"RIGHT", w:0.6}, ...]
  // - q.direction = "Right-wing:0.6, Centrist:0.4"
  // normalize=true => divide by sum(abs(w))
  function getQuestionDirParts(q, normalize=true){
    let parts = [];

    if(Array.isArray(q?.directions) && q.directions.length){
      parts = q.directions
        .map((d, idx)=>{
          const key = normalizeDirKey(d.key ?? d.sectorKey ?? d.poleKey ?? d.dir ?? "");
          let w = Number(d.w ?? d.weight ?? "");
          if(!Number.isFinite(w)) w = Math.pow(0.5, idx);
          return { key, w };
        })
        .filter(p=>isValidDirKey(p.key) && Math.abs(p.w) > 1e-9);
    }

    if(!parts.length && typeof q?.direction === "string" && q.direction.trim()){
      parts = parseDirectionSpec(q.direction);
      if(!parts.length && isValidDirKey(q.direction)){
        parts = [{ key: normalizeDirKey(q.direction), w: 1 }];
      }
    }

    if(!parts.length) return [];
    if(!normalize) return parts;

    const sumAbs = parts.reduce((acc,p)=>acc + Math.abs(p.w), 0);
    if(sumAbs <= 1e-9) return [];
    return parts.map(p=>({ ...p, w: p.w / sumAbs }));
  }

  function combinedVecFromParts(parts){
    let x = 0, y = 0;
    for(const p of parts){
      const v = dirVec(p.key);
      x += v.x * p.w;
      y += v.y * p.w;
    }
    return { x, y };
  }

  function formatDirPartsForUI(parts){
    return (parts || []).map(p=>{
      const d = dirDisplay(p.key);
      return `${d.label}×${Number(p.w).toFixed(2)}`;
    }).join(" + ");
  }

  // ===== END hierarchical pluri-direction support =====

  function angleDist(a,b){
    let d = Math.abs(a-b);
    if(d > 180) d = 360 - d;
    return d;
  }

  function nearestPole(angle360){
    let best = null;
    for(const p of POLES){
      const d = angleDist(angle360, p.angle360);
      if(!best || d < best.d) best = { pole:p, d };
    }
    return best;
  }

  function rangeSize(start,end){
    return (end - start + 360) % 360; // size along increasing direction
  }
  function inRange(angle,start,end){
    if(start < end) return start <= angle && angle < end;
    return (angle >= start) || (angle < end);
  }
  function sectorFromAngle(angle360){
    for(const s of SECTOR_RANGES){
      if(inRange(angle360, s.start, s.end)) return s;
    }
    return SECTOR_RANGES[0];
  }

  function classifyPoint(x,y){
    const r = Math.hypot(x,y);
    if(r <= state.settings.centerRadius){
      return {
        kind:"CENTER",
        poleKey: GREY.key,
        poleName: GREY.name,
        sectorKey: GREY.key,
        sectorName: GREY.name,
        sectorColorName: "Grey",
        filterName: GREY.name,
        sliceName: "Liminal",
        betweenPoles: "Grey Center",
        radicalism:0,
        angle360:0,
        label:"Grey (Center) — Liminal"
      };
    }

    const angleRad = Math.atan2(y,x);
    const deg = angleRad * 180/Math.PI;   // [-180,180]
    const a360 = to360(deg);              // [0,360)

    const sr = sectorFromAngle(a360);
    const sector = SECTORS.find(s=>s.key===sr.sectorKey);

    const rs = rangeSize(sr.start, sr.end);
    const distFromStart = (a360 - sr.start + 360) % 360;
    const distToEnd = rs - distFromStart;
    const nearerStart = (distFromStart <= distToEnd);

    const sliceName = nearerStart ? sr.sliceNearStart : sr.sliceNearEnd;
    const leanPoleKey = nearerStart ? sr.startPole : sr.endPole;

    const poleLean = POLES.find(p=>p.key===leanPoleKey);
    const poleA = POLES.find(p=>p.key===sr.startPole);
    const poleB = POLES.find(p=>p.key===sr.endPole);
    const betweenPoles = `${poleA?.name || sr.startPole} ↔ ${poleB?.name || sr.endPole}`;

    const np = nearestPole(a360);

    const pureByAngle = (r >= state.settings.pureCornerRadius) &&
      (np.d <= Number(state.settings.purePoleAngleToleranceDeg ?? 7));

    const radicalism = clamp(r,0,1);

    let label;
    if(pureByAngle){
      label = `Pure ${np.pole.name}`;
    } else {
      label = `${sliceName} · ${sector?.name || sr.sectorKey} (${sector?.colorName || sr.sectorKey})`;
    }

    return {
      kind: pureByAngle ? "PURE_POLE" : "SECTOR_SLICE",
      poleKey: np.pole.key,
      poleName: np.pole.name,
      poleAngleDistance: np.d,
      sectorKey: sr.sectorKey,
      sectorName: sector?.name || sr.sectorKey,
      sectorColorName: sector?.colorName || sr.sectorKey,
      filterName: sector?.name || sr.sectorKey,
      sliceName,
      leanPoleKey,
      leanPoleName: poleLean?.name || leanPoleKey,
      betweenPoles,
      radicalism,
      angle360: a360,
      label
    };
  }

  // ===== computeScore: supports hierarchical pluri-direction questions =====
  function computeScore(questions, answers){
    const breakdown = [];
    const synergyNotes = [];
    let rawX = 0, rawY = 0;
    let maxSum = 0;

    const tagAgg = new Map();

    for(const q of questions){
      const a = answers[q.id];
      if(!a) continue;

      const ansDef = getAnswerDef(a.choiceKey);
      if(!ansDef) continue;

      const impDef = getImportanceDef(a.importanceKey);
      const weight = Number(q.weight ?? 1);
      const w = weight * Number(impDef.mult ?? 1);

      const dirParts = getQuestionDirParts(q, true);
      if(!dirParts.length) continue;

      const dirVec2 = combinedVecFromParts(dirParts);

      maxSum += Math.abs(w) * 1;

      const baseValue = Number(ansDef.value ?? 0);

      const cx = dirVec2.x * baseValue * w;
      const cy = dirVec2.y * baseValue * w;
      rawX += cx;
      rawY += cy;

      if(Math.abs(baseValue) > 1e-9 && Array.isArray(q.tags)){
        for(const t of q.tags){
          if(!t) continue;
          const key = String(t).toLowerCase().trim();
          if(!key) continue;
          const cur = tagAgg.get(key) || { sum:0, wsum:0 };
          cur.sum += baseValue * w;
          cur.wsum += Math.abs(w);
          tagAgg.set(key, cur);
        }
      }

      breakdown.push({
        qid: q.id,
        text: q.text,

        // compatibility fields:
        direction: dirParts[0]?.key || (q.direction || ""),

        // new:
        directions: dirParts,
        dirText: formatDirPartsForUI(dirParts),

        tags: Array.isArray(q.tags) ? q.tags : [],
        weight,
        importance: a.importanceKey,
        choiceKey: a.choiceKey,
        choiceLabel: ansDef.label,
        baseValue,
        inferredValue: 0,
        w,
        contribX: cx,
        contribY: cy,
        notes: []
      });
    }

    // Synergy: apply along the same combined direction vector
    if(state.settings.synergy?.enabled){
      for(const row of breakdown){
        const q = questions.find(qq=>qq.id===row.qid);
        const ansDef = getAnswerDef(row.choiceKey);
        const special = ansDef?.special || null;
        if(!(special === "neutral" || special === "ambivalent")) continue;
        if(!q?.tags?.length) continue;

        let sum = 0, cnt = 0;
        for(const t of q.tags){
          const key = String(t).toLowerCase().trim();
          const agg = tagAgg.get(key);
          if(!agg || !agg.wsum) continue;
          const v = agg.sum / agg.wsum;
          sum += v; cnt++;
        }
        if(!cnt) continue;
        const tagStance = sum / cnt;

        if(Math.abs(tagStance) < Number(state.settings.synergy.threshold ?? 0.25)) continue;

        const strength = (special === "neutral")
          ? Number(state.settings.synergy.neutralStrength ?? 0.35)
          : Number(state.settings.synergy.ambivalentStrength ?? 0.20);

        const inferred = tagStance * strength;

        const dirVec3 = combinedVecFromParts(row.directions || getQuestionDirParts(q, true));
        const dx = dirVec3.x * inferred * row.w;
        const dy = dirVec3.y * inferred * row.w;

        rawX += dx;
        rawY += dy;

        row.inferredValue = inferred;
        row.contribX += dx;
        row.contribY += dy;

        const note = `Synergy: inferred ${inferred.toFixed(2)} from tag-consistency (avg tag stance ${tagStance.toFixed(2)}), because answer was ${ansDef.label}.`;
        row.notes.push(note);
        synergyNotes.push({ qid: row.qid, text: row.text, note });
      }
    }

    if(maxSum < 1e-9) maxSum = 1;
    let x = rawX / maxSum;
    let y = rawY / maxSum;

    const r = Math.hypot(x,y);
    if(r > 1){ x /= r; y /= r; }

    const cls = classifyPoint(x,y);
    return { x, y, r: Math.hypot(x,y), classification: cls, breakdown, synergyNotes, maxSum };
  }

  // ============================
  // CANVAS DRAWING (POLES = CORNERS)
  // ============================
  function hexToRgba(hex, a){
    const h = (hex||"").trim();
    if(h.startsWith("#") && (h.length===7)){
      const r = parseInt(h.slice(1,3),16);
      const g = parseInt(h.slice(3,5),16);
      const b = parseInt(h.slice(5,7),16);
      return `rgba(${r},${g},${b},${a})`;
    }
    return `rgba(255,255,255,${a})`;
  }

  // shortest signed angular difference a->b in degrees in (-180,180]
  function signedShortestDiff(a,b){
    return ((b - a + 540) % 360) - 180;
  }
  function midAngle(a,b){
    const d = signedShortestDiff(a,b);
    return to360(a + d/2);
  }

  function drawCompass(canvas, points){
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const cx = W/2, cy = H/2;
    const R = Math.min(W,H) * 0.42;

    // pole vertices (corners)
    const polePos = new Map();
    for(const p of POLES){
      const a = rad(p.angle360);
      const px = cx + Math.cos(a)*R;
      const py = cy - Math.sin(a)*R;
      polePos.set(p.key, { x:px, y:py, a360:p.angle360, pole:p });
    }

    // fill sector wedges as triangles bounded by adjacent pole corners
    for (const e of EDGE_SECTORS_CLOCKWISE) {
      const sector = SECTORS.find(s => s.key === e.sectorKey);
      const A = polePos.get(e.poleA);
      const B = polePos.get(e.poleB);
      if (!sector || !A || !B) continue;

      // sector triangle fill
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(A.x, A.y);
      ctx.lineTo(B.x, B.y);
      ctx.closePath();
      ctx.fillStyle = hexToRgba(sector.color, 0.22);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.stroke();

      // sector label at mid-angle between corners
      const m = midAngle(A.a360, B.a360);
      const ma = rad(m);

      const lx = cx + Math.cos(ma) * (R * 0.58);
      const ly = cy - Math.sin(ma) * (R * 0.58);
      ctx.font = "11px system-ui";
      ctx.fillStyle = "rgba(233,238,252,.70)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(sector.name, lx, ly);

      // ---- slice divider (radar line) ----
      // Splits each sector into two slices by drawing a radial line aimed at the sector mid-angle,
      // clipped to the hexagon side segment A-B.
      const cross = (u, v) => u.x * v.y - u.y * v.x;

      // canvas ray direction for angle ma (note: canvas y grows downward)
      const rdir = { x: Math.cos(ma), y: -Math.sin(ma) }; // ray from center
      const sdir = { x: (B.x - A.x), y: (B.y - A.y) };    // segment A->B
      const AC = { x: (A.x - cx), y: (A.y - cy) };

      const denom = cross(rdir, sdir);
      if (Math.abs(denom) > 1e-9) {
        const t = cross(AC, sdir) / denom; // along ray
        const u = cross(AC, rdir) / denom; // along segment

        if (t > 0 && u >= 0 && u <= 1) {
          const ix = cx + rdir.x * t;
          const iy = cy + rdir.y * t;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(ix, iy);
          ctx.strokeStyle = "rgba(255,255,255,.14)";
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    // outer hexagon outline (corners are poles)
    ctx.beginPath();
    const firstKey = POLE_ORDER_CLOCKWISE[0];
    const first = polePos.get(firstKey);
    if(first){
      ctx.moveTo(first.x, first.y);
      for(let i=1;i<POLE_ORDER_CLOCKWISE.length;i++){
        const v = polePos.get(POLE_ORDER_CLOCKWISE[i]);
        if(v) ctx.lineTo(v.x, v.y);
      }
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // grey center
    ctx.beginPath();
    ctx.arc(cx,cy, R*state.settings.centerRadius, 0, Math.PI*2);
    ctx.fillStyle = hexToRgba(GREY.color, 0.28);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.stroke();

    // guide circles
    for(const k of [0.25, 0.5, 0.75, 1.0]){
      ctx.beginPath();
      ctx.arc(cx,cy, R*k, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.06)";
      ctx.stroke();
    }

    // corner rays + labels AT CORNERS (outside the vertices)
    for(const p of POLES){
      const a = rad(p.angle360);
      const x2 = cx + Math.cos(a)*R;
      const y2 = cy - Math.sin(a)*R;

      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(x2,y2);
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.stroke();

      // label near the corner (slightly above/outside)
      const labelR = (p.key === "THIRD" || p.key === "CENTRIST") ? (R * 1.08) : (R * 1.18);
      const lx = cx + Math.cos(a) * labelR;
      const ly = cy - Math.sin(a) * labelR;

      ctx.font = "12px system-ui";
      ctx.fillStyle = "rgba(233,238,252,.86)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(p.name.replace(" Politics",""), lx, ly);
    }

    // center label
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(233,238,252,.70)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Grey", cx, cy);

    // points
    for(const p of points || []){
      const px = cx + p.x * R;
      const py = cy - p.y * R;
      ctx.beginPath();
      ctx.arc(px,py, 6, 0, Math.PI*2);
      ctx.fillStyle = p.color || "rgba(124,156,255,.95)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,.55)";
      ctx.stroke();

      if(p.label){
        ctx.font = "12px system-ui";
        ctx.fillStyle = "rgba(233,238,252,.9)";
        ctx.textAlign = "left";
        ctx.fillText(p.label, px + 10, py - 10);
      }
    }
  }

  // ============================
  // ROUTING + PAGES
  // ============================
  function renderHome(){
    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>How the model works</h2>
          <div class="smallnote">
            <b>Corners (poles)</b> are the six political positions:
            Third-Position (top), Reactionary, Right-wing, Centrist, Left-wing, Syncretic.
            <div class="spacer"></div>
            <b>Colours (sectors)</b> are <i>bridging filters</i> between adjacent corners, split into two slices leaning toward either border.
            <div class="spacer"></div>
            <span class="badge warn">Radicalism</span> is distance from center; the grey center is liminal.
            Far out and close to a corner-line can classify as <b>Pure</b> that pole.
            <div class="spacer"></div>
          </div>
          <div class="hr"></div>
          <div class="row">
            <a class="btn primary" href="#/quiz">Take the test</a>
            <a class="btn" href="#/ledger">Result ledger</a>
            <a class="btn" href="#/suggest">Suggest questions</a>
          </div>
          <div class="spacer"></div>
          <div class="smallnote muted">
            Guest mode is automatic (anonymous auth). You don’t need an account to take the test, save attempts, share, or compare.
          </div>
        </div>

        <div class="card">
          <h2>Compass Preview</h2>
          <div class="canvasWrap">
            <canvas id="c_preview" width="520" height="520"></canvas>
          </div>
          <div class="spacer"></div>
          <div class="smallnote muted"></div>
        </div>
      </div>
    `;
    drawCompass(document.getElementById("c_preview"), [
      { x:0.00, y:0.00, label:"Center", color:"rgba(107,114,128,.95)" },
      { x:0.62, y:0.18, label:"Example", color:"rgba(124,156,255,.95)" },
    ]);
  }

  function safeJsonParse(s){ try{ return JSON.parse(s); }catch{ return null; } }

  function renderQuiz(){
    const qs = state.questions;
    if(!qs.length){
      $app.innerHTML = `
        <div class="card">
          <h2>No questions yet</h2>
          <div class="smallnote muted">An admin must add questions first (Admin → Questions). Or suggest questions in “Suggest Questions”.</div>
        </div>
      `;
      return;
    }

    const key = "hpc_draft_answers_v2";
    const answers = safeJsonParse(localStorage.getItem(key)) || {};
    const answerOptions = state.settings.answerScale;
    const impOptions = state.settings.importanceScale;

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Test</h2>
          <div class="smallnote muted">
            Questions push you toward a <b>direction mix</b> — default hierarchy (primary→secondary→…) unless you assign weights. Your final point is then classified by pole/sector/slice.
          </div>
          <div class="hr"></div>

          <div class="row">
            <button id="saveDraft" class="btn small" type="button">Save draft</button>
            <button id="clearDraft" class="btn small danger" type="button">Clear draft</button>
          </div>

          <div class="spacer"></div>
          <div id="qList" class="list"></div>

          <div class="hr"></div>
          <div class="row">
            <button id="submitAttempt" class="btn good" type="button">Submit attempt</button>
          </div>
          <div class="spacer"></div>
          <div class="smallnote muted">
            Transparency: the ledger stores every question, your answer, importance weight, and each coordinate contribution.
          </div>
        </div>

        <div class="card">
          <h2>Live preview</h2>
          <div class="canvasWrap">
            <canvas id="c_live" width="520" height="520"></canvas>
          </div>
          <div class="spacer"></div>
          <div class="kpi">
            <div class="box">
              <div class="t">Current X</div>
              <div class="v mono" id="kpi_x">0.00</div>
            </div>
            <div class="box">
              <div class="t">Current Y</div>
              <div class="v mono" id="kpi_y">0.00</div>
            </div>
            <div class="box">
              <div class="t">Radicalism (distance)</div>
              <div class="v mono" id="kpi_r">0.00</div>
            </div>
            <div class="box">
              <div class="t">Classification</div>
              <div class="v" id="kpi_label">—</div>
            </div>
          </div>

          <div class="hr"></div>
          <div class="smallnote muted">
            “Synergy” (optional) nudges Neutral/Ambivalent answers using tag-consistency with your non-neutral answers.
          </div>
        </div>
      </div>
    `;

    const $qList = document.getElementById("qList");
    const c = document.getElementById("c_live");

    function renderQuestions(){
      $qList.innerHTML = qs.map((q, idx)=>{
        const a = answers[q.id] || { choiceKey:"N", importanceKey:3 };
        const tags = Array.isArray(q.tags) && q.tags.length ? q.tags : [];

        const partsRaw = getQuestionDirParts(q, false);
        const partsNorm = getQuestionDirParts(q, true);

        const chips = (partsRaw.length ? partsRaw : partsNorm).map(p=>{
          const d = dirDisplay(p.key);
          const col = d.color || "#aaa";
          const label = d.label || p.key;
          return `<span class="badge" style="border-color:${hexToRgba(col,.4)}; background:${hexToRgba(col,.12)}; color:#e9eefc">
            <b style="color:${col}">${htmlEscape(label)}</b>
            × <span class="mono">${Number(p.w).toFixed(2)}</span>
          </span>`;
        }).join(" ");

        const fallback = `<span class="badge">Direction: <b>${htmlEscape(q.direction || "—")}</b></span>`;

        return `
          <div class="item">
            <div class="top">
              <div style="flex:1">
                <p class="title"><span class="badge primary">Q${idx+1}</span> ${htmlEscape(q.text)}</p>
                <div class="meta">
                  <span class="badge">Direction mix:</span>
                  ${chips || fallback}
                  <span class="badge">Weight: <span class="mono">${Number(q.weight ?? 1).toFixed(2)}</span></span>
                  ${tags.length ? `<div class="chips" style="margin-top:6px">${tags.map(t=>`<span class="chip">#${htmlEscape(t)}</span>`).join("")}</div>` : ``}
                </div>
              </div>
            </div>

            <div class="spacer"></div>
            <div class="split">
              <div>
                <label>Answer</label>
                <div class="choiceGrid" data-qid="${q.id}" data-field="choiceKey">
                  ${answerOptions.map(opt=>`
                    <label class="choice ${opt.key===a.choiceKey ? "active":""}">
                      <input type="radio" name="ans_${q.id}" value="${opt.key}" ${opt.key===a.choiceKey ? "checked":""}/>
                      <span class="k">${htmlEscape(opt.key)}</span>
                      <span>${htmlEscape(opt.label)}</span>
                    </label>
                  `).join("")}
                </div>
              </div>
              <div>
                <label>Importance</label>
                <select data-qid="${q.id}" data-field="importanceKey">
                  ${impOptions.map(opt=>`
                    <option value="${opt.key}" ${Number(opt.key)===Number(a.importanceKey) ? "selected":""}>
                      ${htmlEscape(opt.label)} (×${Number(opt.mult).toFixed(2)})
                    </option>
                  `).join("")}
                </select>
              </div>
            </div>
          </div>
        `;
      }).join("");

      // Answer radios
      $qList.querySelectorAll('.choiceGrid[data-field="choiceKey"] input[type="radio"]').forEach(inp=>{
        inp.addEventListener("change", ()=>{
          const grid = inp.closest(".choiceGrid");
          const qid = grid.getAttribute("data-qid");
          answers[qid] = answers[qid] || { choiceKey:"N", importanceKey:3 };
          answers[qid].choiceKey = inp.value;

          // active styles
          grid.querySelectorAll(".choice").forEach(l=>l.classList.remove("active"));
          inp.closest(".choice").classList.add("active");

          const preview = computeScore(qs, answers);
          updateLive(preview);
          localStorage.setItem(key, JSON.stringify(answers));
        });
      });

      // Importance selects (keep native)
      $qList.querySelectorAll('select[data-field="importanceKey"]').forEach(sel=>{
        sel.addEventListener("change", ()=>{
          const qid = sel.getAttribute("data-qid");
          answers[qid] = answers[qid] || { choiceKey:"N", importanceKey:3 };
          answers[qid].importanceKey = Number(sel.value);

          const preview = computeScore(qs, answers);
          updateLive(preview);
          localStorage.setItem(key, JSON.stringify(answers));
        });
      });
    }

    function updateLive(res){
      document.getElementById("kpi_x").textContent = res.x.toFixed(3);
      document.getElementById("kpi_y").textContent = res.y.toFixed(3);
      document.getElementById("kpi_r").textContent = res.r.toFixed(3);
      document.getElementById("kpi_label").textContent = res.classification.label;
      drawCompass(c, [{ x: res.x, y: res.y, label:"You", color:"rgba(124,156,255,.95)" }]);
    }

    document.getElementById("saveDraft").onclick = ()=>{
      localStorage.setItem(key, JSON.stringify(answers));
      toast("Draft saved locally.");
    };

    document.getElementById("clearDraft").onclick = ()=>{
      localStorage.removeItem(key);
      for(const k of Object.keys(answers)) delete answers[k];
      renderQuestions();
      updateLive(computeScore(qs, answers));
      toast("Draft cleared.");
    };

    document.getElementById("submitAttempt").onclick = async ()=>{
      if(Object.keys(answers).length === 0){
        toast("Answer at least one question.");
        return;
      }
      if(!state.user){
        toast("Still connecting… try again in a moment.");
        return;
      }

      const res = computeScore(qs, answers);

      try{
        const attemptDoc = {
          uid: state.user.uid,
          createdAt: serverTimestamp(),
          public: false,
          answers,
          computed: {
            x: res.x, y: res.y, r: res.r,
            kind: res.classification.kind,
            poleKey: res.classification.poleKey,
            poleName: res.classification.poleName,
            poleAngleDistance: res.classification.poleAngleDistance ?? null,

            sectorKey: res.classification.sectorKey,
            sectorName: res.classification.sectorName,
            sectorColorName: res.classification.sectorColorName,
            filterName: res.classification.filterName,
            sliceName: res.classification.sliceName,
            leanPoleKey: res.classification.leanPoleKey ?? null,
            leanPoleName: res.classification.leanPoleName ?? null,
            betweenPoles: res.classification.betweenPoles,

            label: res.classification.label,
            radicalism: res.classification.radicalism,
            angle360: res.classification.angle360,

            maxSum: res.maxSum,
            synergyNotes: res.synergyNotes,
            breakdown: res.breakdown,
            settingsSnapshot: state.settings,
          }
        };
        const ref = await addDoc(collection(db, "attempts"), attemptDoc);
        localStorage.removeItem(key);
        state.lastAttempt = ref.id;
        toast("Attempt saved.");
        navTo(`#/attempt/${ref.id}`);
      }catch(e){
        toast("Failed to save attempt: " + (e?.message || e));
      }
    };

    renderQuestions();
    updateLive(computeScore(qs, answers));
  }

  async function fetchMyAttempts(){
    if(!state.user) return [];
    const out = [];
    const qref = query(collection(db, "attempts"), where("uid","==", state.user.uid), orderBy("createdAt","desc"), limit(50));
    const snap = await getDocs(qref);
    snap.forEach(d=> out.push({ id:d.id, ...d.data() }));
    return out;
  }

  async function fetchAttemptById(id){
    const snap = await getDoc(doc(db, "attempts", id));
    if(!snap.exists()) return null;
    return { id:snap.id, ...snap.data() };
  }

  function attemptCanView(attempt){
    if(!attempt) return false;
    if(attempt.public === true) return true;
    if(state.user && attempt.uid === state.user.uid) return true;
    return false;
  }

  function renderLedgerTables(attempt){
    const c = attempt.computed;
    const breakdown = Array.isArray(c.breakdown) ? c.breakdown : [];
    const synergy = Array.isArray(c.synergyNotes) ? c.synergyNotes : [];

    const rows = breakdown.map((r, i)=>{
      const parts = Array.isArray(r.directions) ? r.directions : [];
      const firstKey = parts[0]?.key || r.direction;
      const d0 = dirDisplay(firstKey);
      const color = d0?.color || "#bbb";

      const dirLabel = parts.length
        ? formatDirPartsForUI(parts)
        : (r.dirText || d0?.label || (r.direction || "—"));

      const note = (r.notes && r.notes.length)
        ? `<div class="smallnote warnText" style="margin-top:6px">${htmlEscape(r.notes.join(" "))}</div>`
        : "";

      return `
        <tr>
          <td class="mono">${i+1}</td>
          <td>${htmlEscape(r.text)}</td>
          <td>
            <span class="badge" style="border-color:${hexToRgba(color,.45)}; background:${hexToRgba(color,.12)}; color:#e9eefc">
              ${htmlEscape(dirLabel)}
            </span>
          </td>
          <td>${htmlEscape(r.choiceLabel)} <div class="meta mono">${Number(r.baseValue).toFixed(2)}${r.inferredValue ? ` + ${Number(r.inferredValue).toFixed(2)}(sy)` : ``}</div></td>
          <td class="mono">${Number(r.weight).toFixed(2)} × ${Number(r.w/Number(r.weight||1)).toFixed(2)} (imp)</td>
          <td class="mono">${Number(r.contribX).toFixed(4)}</td>
          <td class="mono">${Number(r.contribY).toFixed(4)}${note}</td>
        </tr>
      `;
    }).join("");

    const sy = synergy.length ? `
      <div class="item">
        <div class="top">
          <div>
            <div class="title">Synergy notes (${synergy.length})</div>
            <div class="meta">Applied only when your answer was Neutral/Ambivalent and your tag stance was consistent enough.</div>
          </div>
        </div>
        <div class="spacer"></div>
        <div class="list">
          ${synergy.slice(0,50).map(s=>`
            <div class="item">
              <div class="title">${htmlEscape(s.text)}</div>
              <div class="smallnote warnText">${htmlEscape(s.note)}</div>
            </div>
          `).join("")}
        </div>
      </div>
    ` : `<div class="smallnote muted">No synergy adjustments applied.</div>`;

    return `
      <div class="row">
        <span class="badge primary">Final X: <span class="mono">${c.x.toFixed(4)}</span></span>
        <span class="badge primary">Final Y: <span class="mono">${c.y.toFixed(4)}</span></span>
        <span class="badge warn">Distance: <span class="mono">${c.r.toFixed(4)}</span></span>
      </div>
      <div class="spacer"></div>

      <div class="item">
        <div class="title">${htmlEscape(c.label || "—")}</div>
        <div class="meta">
          <span class="badge primary">Pole: ${htmlEscape(c.poleName || "—")}</span>
          <span class="badge">Between: ${htmlEscape(c.betweenPoles || "—")}</span>
          ${c.filterName ? `<span class="badge">Filter: ${htmlEscape(c.filterName)} (${htmlEscape(c.sectorColorName || "")})</span>` : ``}
          ${c.sliceName ? `<span class="badge warn">Slice: ${htmlEscape(c.sliceName)}</span>` : ``}
        </div>
      </div>

      <div class="spacer"></div>
      <table class="table">
        <thead>
          <tr>
            <th>#</th>
            <th>Question</th>
            <th>Direction</th>
            <th>Answer</th>
            <th>Weight × Importance</th>
            <th>ΔX</th>
            <th>ΔY</th>
          </tr>
        </thead>
        <tbody>
          ${rows || `<tr><td colspan="7" class="muted">No breakdown stored.</td></tr>`}
        </tbody>
      </table>

      <div class="spacer"></div>
      ${sy}
    `;
  }

  async function renderAttemptPage(id, isShare=false){
    const attempt = await fetchAttemptById(id);
    if(!attempt){
      $app.innerHTML = `<div class="card"><h2>Not found</h2><div class="smallnote muted">No attempt with that ID.</div></div>`;
      return;
    }
    if(!attemptCanView(attempt)){
      $app.innerHTML = `
        <div class="card">
          <h2>Access denied</h2>
          <div class="smallnote muted">This attempt is private. Ask the owner to make it public and share the link.</div>
        </div>
      `;
      return;
    }

    const c = attempt.computed;
    const canvasId = "c_attempt";
    const isMine = state.user && attempt.uid === state.user.uid;

    const sector = SECTORS.find(s=>s.key===c.sectorKey);
    const sectorColor = sector?.color || getCSS("--grey");

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Result</h2>
          <div class="row">
            <span class="badge primary">X: <span class="mono">${c.x.toFixed(3)}</span></span>
            <span class="badge primary">Y: <span class="mono">${c.y.toFixed(3)}</span></span>
            <span class="badge warn">Radicalism: <span class="mono">${c.r.toFixed(3)}</span></span>
          </div>
          <div class="spacer"></div>

          <div class="item">
            <div class="title">${htmlEscape(c.label || "—")}</div>
            <div class="meta">
              <span class="badge primary">Pole: ${htmlEscape(c.poleName || "—")}</span>
              <span class="badge">Between: ${htmlEscape(c.betweenPoles || "—")}</span>
              ${c.filterName ? `<span class="badge" style="border-color:${hexToRgba(sectorColor,.4)}; background:${hexToRgba(sectorColor,.12)}; color:#e9eefc">
                Filter: <b style="color:${sectorColor}">${htmlEscape(c.filterName)}</b> (${htmlEscape(c.sectorColorName || "")})
              </span>` : ``}
              ${c.sliceName ? `<span class="badge warn">Slice: ${htmlEscape(c.sliceName)}</span>` : ``}
            </div>
            <div class="meta">Attempt: ${htmlEscape(attempt.id)} · ${htmlEscape(fmtTime(attempt.createdAt))}</div>
          </div>

          <div class="spacer"></div>
          <div class="canvasWrap">
            <canvas id="${canvasId}" width="520" height="520"></canvas>
          </div>
          <div class="spacer"></div>

          ${isMine ? `
            <div class="row">
              <button class="btn small ${attempt.public ? 'warn' : ''}" type="button" data-action="togglePublic">
                ${attempt.public ? 'Make private' : 'Make public (shareable)'}
              </button>
              <button class="btn small" type="button" data-action="copyLink" ${attempt.public ? "" : "disabled"}>
                Copy share link
              </button>
              <a class="btn small" href="#/compare?ids=${encodeURIComponent(attempt.id)}">Compare</a>
            </div>
            <div class="spacer"></div>
            <div class="smallnote muted">
              Public share links are readable by anyone with the link. Private attempts are visible only to the owner UID.
            </div>
          ` : `
            <div class="smallnote muted">Read-only view (sharing controls require ownership).</div>
          `}

          <div class="hr"></div>
          <div class="row">
            <a class="btn" href="#/ledger">Open ledger</a>
            <a class="btn primary" href="#/quiz">Retake test</a>
          </div>
        </div>

        <div class="card">
          <h2>Transparency Ledger</h2>
          <div class="smallnote muted">
            Exact computation: per-question weight, importance multiplier, answer value, and final contribution.
          </div>
          <div class="hr"></div>
          ${renderLedgerTables(attempt)}
        </div>
      </div>
    `;

    drawCompass(document.getElementById(canvasId), [
      { x: c.x, y: c.y, label: isShare ? "Shared" : "You", color:"rgba(124,156,255,.95)" }
    ]);

    const btnToggle = $app.querySelector('[data-action="togglePublic"]');
    const btnCopy = $app.querySelector('[data-action="copyLink"]');

    if(btnToggle){
      btnToggle.onclick = async ()=>{
        try{
          const newVal = !(attempt.public === true);
          await updateDoc(doc(db,"attempts", attempt.id), { public: newVal });
          attempt.public = newVal;
          toast(newVal ? "Now public (shareable)." : "Now private.");
          render();
        }catch(e){
          toast("Failed: " + (e?.message || e));
        }
      };
    }

    if(btnCopy){
      btnCopy.onclick = async ()=>{
        try{
          const link = `${location.origin}${location.pathname}#/share/${attempt.id}`;
          await navigator.clipboard.writeText(link);
          toast("Share link copied.");
        }catch{
          toast("Copy failed. Manually copy from address bar.");
        }
      };
    }
  }

  async function renderLedger(){
    if(!state.user){
      $app.innerHTML = `<div class="card"><h2>Connecting…</h2><div class="smallnote muted">Guest session is loading.</div></div>`;
      return;
    }

    let attempts = [];
    try{
      attempts = await fetchMyAttempts();
    }catch(e){
      $app.innerHTML = `<div class="card"><h2>Error</h2><div class="smallnote muted">${htmlEscape(e?.message || e)}</div></div>`;
      return;
    }

    const items = attempts.map(a=>{
      const c = a.computed;
      const badge = a.public ? `<span class="badge good">Public</span>` : `<span class="badge">Private</span>`;
      const sec = SECTORS.find(s=>s.key===c?.sectorKey);
      const col = sec?.color || getCSS("--grey");

      return `
        <div class="item">
          <div class="top">
            <div>
              <div class="title">
                <a href="#/attempt/${a.id}">${htmlEscape(c?.label || "Attempt")}</a>
              </div>
              <div class="meta">
                ${badge}
                <span class="badge">Time: ${htmlEscape(fmtTime(a.createdAt))}</span>
                <span class="badge primary">Pole: ${htmlEscape(c?.poleName || "—")}</span>
                ${c?.betweenPoles ? `<span class="badge">Between: ${htmlEscape(c.betweenPoles)}</span>` : ``}
                ${c?.filterName ? `<span class="badge" style="border-color:${hexToRgba(col,.4)}; background:${hexToRgba(col,.12)}; color:#e9eefc">
                  Filter: <b style="color:${col}">${htmlEscape(c.filterName)}</b>
                </span>` : ``}
                ${c?.sliceName ? `<span class="badge warn">Slice: ${htmlEscape(c.sliceName)}</span>` : ``}
                <span class="badge primary">X <span class="mono">${Number(c?.x ?? 0).toFixed(3)}</span></span>
                <span class="badge primary">Y <span class="mono">${Number(c?.y ?? 0).toFixed(3)}</span></span>
                <span class="badge warn">R <span class="mono">${Number(c?.r ?? 0).toFixed(3)}</span></span>
              </div>
            </div>
            <div class="row">
              ${a.public ? `<a class="btn small" href="#/share/${a.id}">Open share view</a>` : ``}
              <a class="btn small" href="#/compare?ids=${encodeURIComponent(a.id)}">Compare</a>
            </div>
          </div>
        </div>
      `;
    }).join("");

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Your attempts</h2>
          <div class="smallnote muted">
            ${isGuest()
              ? `You are currently a <b>Guest</b>. Attempts are saved under this device/browser unless you upgrade.`
              : `Attempts are tied to your account and persist across devices.`
            }
          </div>
          <div class="hr"></div>
          <div class="list">
            ${items || `<div class="smallnote muted">No attempts yet. Take the test.</div>`}
          </div>
          <div class="hr"></div>
          <a class="btn primary" href="#/quiz">Take / retake test</a>
        </div>

        <div class="card">
          <h2>Quick compare</h2>
          <div class="smallnote muted">Enter one or more attempt IDs (comma-separated) to plot on the same compass.</div>
          <div class="spacer"></div>
          <input id="cmp_ids" placeholder="e.g. AbC123..., DeF456..., ..." />
          <div class="spacer"></div>
          <button class="btn good" id="cmp_go" type="button">Compare</button>
          <div class="hr"></div>
          <div class="smallnote muted">If an ID belongs to someone else, it must be public to load.</div>
        </div>
      </div>
    `;

    document.getElementById("cmp_go").onclick = ()=>{
      const val = document.getElementById("cmp_ids").value.trim();
      if(!val) return toast("Enter at least one attempt ID.");
      navTo(`#/compare?ids=${encodeURIComponent(val)}`);
    };
  }

  async function renderCompare(){
    const { q } = route();
    const idsParam = (q.get("ids") || "").trim();
    const ids = idsParam ? idsParam.split(",").map(s=>s.trim()).filter(Boolean) : [];

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Compare attempts</h2>
          <div class="smallnote muted">Plot multiple attempts (yours and/or public shared attempts) on one compass.</div>
          <div class="spacer"></div>
          <label>Attempt IDs (comma-separated)</label>
          <input id="cmp_in" value="${htmlEscape(idsParam)}" placeholder="id1, id2, id3" />
          <div class="spacer"></div>
          <button class="btn good" id="cmp_btn" type="button">Load</button>
          <div class="hr"></div>
          <div id="cmp_list" class="list"></div>
        </div>

        <div class="card">
          <h2>Compass</h2>
          <div class="canvasWrap">
            <canvas id="c_cmp" width="520" height="520"></canvas>
          </div>
          <div class="spacer"></div>
          <div class="smallnote muted">Each dot is one attempt. Use the ledger per attempt for full transparency.</div>
        </div>
      </div>
    `;

    document.getElementById("cmp_btn").onclick = ()=>{
      const val = document.getElementById("cmp_in").value.trim();
      navTo(`#/compare?ids=${encodeURIComponent(val)}`);
    };

    if(!ids.length){
      document.getElementById("cmp_list").innerHTML = `<div class="smallnote muted">Enter attempt IDs above.</div>`;
      drawCompass(document.getElementById("c_cmp"), []);
      return;
    }

    const attempts = [];
    const errors = [];
    for(const id of ids.slice(0,10)){
      try{
        const a = await fetchAttemptById(id);
        if(!a) { errors.push(`${id}: not found`); continue; }
        if(!attemptCanView(a)) { errors.push(`${id}: private`); continue; }
        attempts.push(a);
      }catch(e){
        errors.push(`${id}: ${e?.message || e}`);
      }
    }

    const colors = [
      "rgba(124,156,255,.95)",
      "rgba(68,239,154,.95)",
      "rgba(255,193,77,.95)",
      "rgba(255,90,115,.95)",
      "rgba(180,83,9,.95)",
      "rgba(59,130,246,.95)",
      "rgba(139,92,246,.95)",
    ];

    drawCompass(document.getElementById("c_cmp"), attempts.map((a,i)=>({
      x:a.computed.x, y:a.computed.y, label:String(i+1), color: colors[i % colors.length]
    })));

    const list = attempts.map((a,i)=>{
      const c = a.computed;
      const badge = a.public ? `<span class="badge good">Public</span>` : `<span class="badge">Private (yours)</span>`;
      return `
        <div class="item">
          <div class="top">
            <div>
              <div class="title">
                <span class="badge primary">#${i+1}</span>
                <a href="#/${a.public ? "share" : "attempt"}/${a.id}">${htmlEscape(c.label || "Attempt")}</a>
              </div>
              <div class="meta">
                ${badge}
                <span class="badge">Time: ${htmlEscape(fmtTime(a.createdAt))}</span>
                <span class="badge primary">Pole: ${htmlEscape(c.poleName || "—")}</span>
                ${c.betweenPoles ? `<span class="badge">Between: ${htmlEscape(c.betweenPoles)}</span>` : ``}
                ${c.filterName ? `<span class="badge">Filter: ${htmlEscape(c.filterName)} (${htmlEscape(c.sectorColorName||"")})</span>` : ``}
                ${c.sliceName ? `<span class="badge warn">Slice: ${htmlEscape(c.sliceName)}</span>` : ``}
                <span class="badge primary">X <span class="mono">${c.x.toFixed(3)}</span></span>
                <span class="badge primary">Y <span class="mono">${c.y.toFixed(3)}</span></span>
                <span class="badge warn">R <span class="mono">${c.r.toFixed(3)}</span></span>
              </div>
            </div>
          </div>
        </div>
      `;
    }).join("");

    const errHtml = errors.length ? `
      <div class="item">
        <div class="title dangerText">Some IDs could not be loaded</div>
        <div class="smallnote muted">${errors.map(e=>`• ${htmlEscape(e)}`).join("<br/>")}</div>
      </div>
    ` : "";

    document.getElementById("cmp_list").innerHTML = errHtml + (list || `<div class="smallnote muted">Nothing to show.</div>`);
  }

  async function renderSuggest(){
    if(!state.user){
      $app.innerHTML = `<div class="card"><h2>Connecting…</h2><div class="smallnote muted">Guest session is loading.</div></div>`;
      return;
    }
    if(isGuest()){
      $app.innerHTML = `
        <div class="card">
          <h2>Suggest questions</h2>
          <div class="smallnote muted">
            Suggestions/voting are restricted to non-Guest accounts (anti-spam).
            <div class="spacer"></div>
            You can still take the test and share results as Guest.
          </div>
          <div class="spacer"></div>
          <button class="btn good" type="button" onclick="location.hash='#/login'">Sign in / Upgrade</button>
        </div>
      `;
      return;
    }

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Submit a suggestion</h2>
          <div class="smallnote muted">Suggestions can be upvoted/downvoted. Admin can accept/reject or promote into real questions.</div>
          <div class="hr"></div>

          <label>Question text</label>
          <textarea id="s_text" placeholder="Write a statement/question..."></textarea>
          <div class="spacer"></div>

          <label>Directions (comma-separated, hierarchical)</label>
          <input id="s_dirs" placeholder="e.g. Right-wing, Centrist, Left-wing" value="Right-wing" />
          <div class="smallnote muted" style="margin-top:6px">
            Keys: <span class="mono">Right-wing, Centrist, Left-wing, Syncretic, Reactionary, Third-Position</span>.
            Use <span class="mono">></span> for hierarchy, or add explicit weights like <span class="mono">Right-wing:0.6, Centrist:0.4</span>.
          </div>

          <div class="spacer"></div>
          <label>Weight</label>
          <input id="s_weight" type="number" step="0.05" value="1.00" />

          <div class="spacer"></div>
          <label>Tags (comma-separated)</label>
          <input id="s_tags" placeholder="e.g. nationalism, economy, religion, lgbtq, authority" />
          <div class="spacer"></div>

          <button id="s_submit" class="btn good" type="button">Submit suggestion</button>
          <div class="spacer"></div>
          <div class="smallnote muted">Keep it clean and testable: one claim per question.</div>
        </div>

        <div class="card">
          <h2>Suggestions (top)</h2>
          <div class="row">
            <button class="btn small" id="filterAll" type="button">All</button>
            <button class="btn small" id="filterPending" type="button">Pending</button>
            <button class="btn small" id="filterAccepted" type="button">Accepted</button>
            <button class="btn small" id="filterRejected" type="button">Rejected</button>
          </div>
          <div class="spacer"></div>
          <div id="s_list" class="list"></div>
        </div>
      </div>
    `;

    document.getElementById("s_submit").onclick = async ()=>{
      const text = document.getElementById("s_text").value.trim();
      const dirsSpec = document.getElementById("s_dirs").value.trim();
      const directions = parseDirectionSpec(dirsSpec);
      const weight = Number(document.getElementById("s_weight").value || 1);
      const tagsRaw = document.getElementById("s_tags").value.trim();
      const tags = tagsRaw ? tagsRaw.split(",").map(t=>t.trim()).filter(Boolean) : [];

      if(text.length < 8) return toast("Write a longer question.");
      if(!directions.length) return toast("Provide at least one valid direction (e.g. Right-wing or Right-wing:0.6, Centrist:0.4).");

      try{
        await addDoc(collection(db,"suggestions"), {
          text,
          directions,                    // NEW
          direction: directions[0].key,  // compatibility
          weight: clamp(weight, 0.05, 5),
          tags,
          status: "pending",
          score: 0,
          createdBy: state.user.uid,
          createdAt: serverTimestamp()
        });
        toast("Suggestion submitted.");
        document.getElementById("s_text").value = "";
        document.getElementById("s_tags").value = "";
        await loadSuggestions("pending");
      }catch(e){
        toast("Failed: " + (e?.message || e));
      }
    };

    async function vote(sid, dir){
      try{
        const sugRef = doc(db, "suggestions", sid);
        const voteRef = doc(db, "suggestions", sid, "votes", state.user.uid);

        await runTransaction(db, async (tx)=>{
          const vSnap = await tx.get(voteRef);
          const cur = vSnap.exists() ? Number(vSnap.data().v || 0) : 0;
          let next = dir;
          if(cur === dir) next = 0;

          const delta = next - cur;
          if(delta !== 0) tx.update(sugRef, { score: increment(delta) });

          if(next === 0){
            if(vSnap.exists()) tx.delete(voteRef);
          }else{
            tx.set(voteRef, { v: next, updatedAt: serverTimestamp() });
          }
        });

        toast("Vote recorded.");
        await loadSuggestions(activeFilter);
      }catch(e){
        toast("Vote failed: " + (e?.message || e));
      }
    }

    async function adminSetStatus(sid, status){
      try{
        await updateDoc(doc(db,"suggestions", sid), { status });
        toast("Status updated.");
        await loadSuggestions(activeFilter);
      }catch(e){
        toast("Failed: " + (e?.message || e));
      }
    }

    async function adminPromoteToQuestion(sug){
      try{
        const dirs = (Array.isArray(sug.directions) && sug.directions.length)
          ? sug.directions
          : (typeof sug.direction === "string" ? parseDirectionSpec(sug.direction) : []);

        if(!dirs.length && typeof sug.direction === "string" && isValidDirKey(sug.direction)){
          dirs.push({ key: normalizeDirKey(sug.direction), w: 1 });
        }
        if(!dirs.length) return toast("Cannot promote: suggestion has no valid directions.");

        await addDoc(collection(db,"questions"), {
          text: sug.text,
          directions: dirs,             // NEW
          direction: dirs[0].key,       // compatibility
          weight: Number(sug.weight ?? 1),
          tags: Array.isArray(sug.tags) ? sug.tags : [],
          enabled: true,
          createdBy: state.user.uid,
          createdAt: serverTimestamp()
        });
        await updateDoc(doc(db,"suggestions", sug.id), { status:"accepted" });
        toast("Promoted into real question.");
        await loadQuestions();
        await loadSuggestions(activeFilter);
      }catch(e){
        toast("Promote failed: " + (e?.message || e));
      }
    }

    let activeFilter = "pending";

    document.getElementById("filterAll").onclick = ()=> loadSuggestions("all");
    document.getElementById("filterPending").onclick = ()=> loadSuggestions("pending");
    document.getElementById("filterAccepted").onclick = ()=> loadSuggestions("accepted");
    document.getElementById("filterRejected").onclick = ()=> loadSuggestions("rejected");

    async function loadSuggestions(filter){
      activeFilter = filter;
      const out = [];
      try{
        let qref;
        if(filter === "all"){
          qref = query(collection(db,"suggestions"), orderBy("score","desc"), orderBy("createdAt","desc"), limit(60));
        }else{
          qref = query(collection(db,"suggestions"), where("status","==", filter), orderBy("score","desc"), orderBy("createdAt","desc"), limit(60));
        }
        const snap = await getDocs(qref);
        snap.forEach(d=> out.push({ id:d.id, ...d.data() }));
      }catch{
        try{
          const snap = await getDocs(collection(db,"suggestions"));
          snap.forEach(d=>{
            const data = d.data();
            if(filter==="all" || data.status===filter) out.push({ id:d.id, ...data });
          });
          out.sort((a,b)=> (b.score||0)-(a.score||0));
        }catch(_){}
      }

      const $list = document.getElementById("s_list");
      if(!out.length){
        $list.innerHTML = `<div class="smallnote muted">No suggestions found.</div>`;
        return;
      }

      const myVotes = new Map();
      for(const s of out){
        try{
          const vSnap = await getDoc(doc(db, "suggestions", s.id, "votes", state.user.uid));
          if(vSnap.exists()) myVotes.set(s.id, Number(vSnap.data().v||0));
        }catch(_){}
      }

      $list.innerHTML = out.map(s=>{
        const parts = getQuestionDirParts(s, false);
        const mv = myVotes.get(s.id) || 0;
        const tags = Array.isArray(s.tags) ? s.tags : [];

        const statusBadge =
          s.status==="accepted" ? `<span class="badge good">Accepted</span>` :
          s.status==="rejected" ? `<span class="badge bad">Rejected</span>` :
          `<span class="badge warn">Pending</span>`;

        const chips = parts.map(p=>{
          const d = dirDisplay(p.key);
          const col = d.color || "#aaa";
          const label = d.label || p.key;
          return `<span class="badge" style="border-color:${hexToRgba(col,.4)}; background:${hexToRgba(col,.12)}; color:#e9eefc">
            <b style="color:${col}">${htmlEscape(label)}</b> × <span class="mono">${Number(p.w).toFixed(2)}</span>
          </span>`;
        }).join(" ");

        return `
          <div class="item">
            <div class="top">
              <div style="flex:1">
                <div class="title">${htmlEscape(s.text)}</div>
                <div class="meta">
                  ${statusBadge}
                  <span class="badge">Direction mix:</span>
                  ${chips || `<span class="badge">${htmlEscape(s.direction || "—")}</span>`}
                  <span class="badge">Weight: <span class="mono">${Number(s.weight ?? 1).toFixed(2)}</span></span>
                  <span class="badge primary">Score: <span class="mono">${Number(s.score ?? 0)}</span></span>
                  <span class="badge">Time: ${htmlEscape(fmtTime(s.createdAt))}</span>
                </div>
                ${tags.length ? `<div class="chips" style="margin-top:6px">${tags.map(t=>`<span class="chip">#${htmlEscape(t)}</span>`).join("")}</div>` : ``}
              </div>
              <div class="row">
                <button class="btn small ${mv===1?'good':''}" data-vote="up" data-id="${s.id}" type="button">▲</button>
                <button class="btn small ${mv===-1?'danger':''}" data-vote="down" data-id="${s.id}" type="button">▼</button>
              </div>
            </div>

            ${state.isAdmin ? `
              <div class="hr"></div>
              <div class="row">
                <button class="btn small warn" data-admin="accept" data-id="${s.id}" type="button">Accept</button>
                <button class="btn small danger" data-admin="reject" data-id="${s.id}" type="button">Reject</button>
                <button class="btn small good" data-admin="promote" data-id="${s.id}" type="button">Promote to Question</button>
              </div>
            ` : ``}
          </div>
        `;
      }).join("");

      $list.querySelectorAll("[data-vote]").forEach(btn=>{
        btn.onclick = ()=>{
          const id = btn.getAttribute("data-id");
          const type = btn.getAttribute("data-vote");
          vote(id, type==="up" ? 1 : -1);
        };
      });

      if(state.isAdmin){
        $list.querySelectorAll("[data-admin]").forEach(btn=>{
          btn.onclick = async ()=>{
            const id = btn.getAttribute("data-id");
            const act = btn.getAttribute("data-admin");
            if(act==="accept") return adminSetStatus(id, "accepted");
            if(act==="reject") return adminSetStatus(id, "rejected");
            if(act==="promote"){
              const sug = out.find(x=>x.id===id);
              if(!sug) return;
              return adminPromoteToQuestion(sug);
            }
          };
        });
      }
    }

    await loadSuggestions("pending");
  }

  async function renderAdmin(){
    if(!state.user){
      $app.innerHTML = `<div class="card"><h2>Admin</h2><div class="smallnote muted">Connecting…</div></div>`;
      return;
    }
    if(isGuest()){
      $app.innerHTML = `
        <div class="card">
          <h2>Admin</h2>
          <div class="smallnote muted">
            Admin requires a non-Guest account.
            <div class="spacer"></div>
            <button class="btn good" type="button" onclick="location.hash='#/login'">Sign in / Upgrade</button>
          </div>
        </div>
      `;
      return;
    }
    if(!state.isAdmin){
      $app.innerHTML = `
        <div class="card">
          <h2>Admin</h2>
          <div class="smallnote muted">
            Access denied. To become admin, create Firestore doc:
            <div class="spacer"></div>
            <div class="mono">admins/${htmlEscape(state.user.uid)}</div>
          </div>
        </div>
      `;
      return;
    }

    $app.innerHTML = `
      <div class="grid cols2">
        <div class="card">
          <h2>Questions</h2>
          <div class="smallnote muted">Add/disable/delete questions. Each question pushes toward a <b>direction mix</b> (one or more poles, hierarchical by default).</div>
          <div class="hr"></div>

          <label>Question text</label>
          <textarea id="q_text" placeholder="Statement / question..."></textarea>
          <div class="spacer"></div>

          <label>Directions (comma-separated, hierarchical)</label>
          <input id="q_dirs" placeholder="e.g. Right-wing, Centrist, Left-wing" value="Right-wing" />
          <div class="smallnote muted" style="margin-top:6px">
            Keys: <span class="mono">Right-wing, Centrist, Left-wing, Syncretic, Reactionary, Third-Position</span>.
            Use <span class="mono">></span> for hierarchy, or add explicit weights like <span class="mono">Right-wing:0.6, Centrist:0.4</span>.
          </div>

          <div class="spacer"></div>
          <label>Weight</label>
          <input id="q_weight" type="number" step="0.05" value="1.00" />

          <div class="spacer"></div>
          <label>Tags (comma-separated)</label>
          <input id="q_tags" placeholder="e.g. economy, nationalism, religion, lgbtq, authority" />
          <div class="spacer"></div>

          <div class="row">
            <button id="q_add" class="btn good" type="button">Add question</button>
            <button id="q_refresh" class="btn" type="button">Refresh list</button>
          </div>

          <div class="hr"></div>
          <div id="q_list" class="list"></div>
        </div>

        <div class="card">
          <h2>Scoring settings</h2>
          <div class="smallnote muted">Admin can modify answer values, importance multipliers, synergy parameters, pole tolerance, etc. (JSON).</div>
          <div class="hr"></div>

          <label>settings/scoring (JSON)</label>
          <textarea id="set_json" class="mono" spellcheck="false"></textarea>
          <div class="spacer"></div>
          <div class="row">
            <button id="set_save" class="btn good" type="button">Save settings</button>
            <button id="set_reset" class="btn danger" type="button">Reset to defaults (local)</button>
            <button id="set_reload" class="btn" type="button">Reload from Firestore</button>
          </div>
          <div class="spacer"></div>
          <div class="smallnote muted">Each attempt stores a snapshot of settings so old results remain explainable.</div>
        </div>
      </div>
    `;

    document.getElementById("set_json").value = JSON.stringify(state.settings, null, 2);

    document.getElementById("set_reset").onclick = ()=>{
      document.getElementById("set_json").value = JSON.stringify(DEFAULT_SETTINGS, null, 2);
      toast("Reset editor to defaults (not saved yet).");
    };

    document.getElementById("set_reload").onclick = async ()=>{
      await loadSettings();
      document.getElementById("set_json").value = JSON.stringify(state.settings, null, 2);
      toast("Reloaded from Firestore.");
    };

    document.getElementById("set_save").onclick = async ()=>{
      try{
        const obj = JSON.parse(document.getElementById("set_json").value);
        await setDoc(doc(db,"settings","scoring"), obj, { merge:false });
        await loadSettings();
        toast("Settings saved.");
      }catch(e){
        toast("Save failed: " + (e?.message || e));
      }
    };

    async function refreshQuestionList(){
      const out = [];
      try{
        const snap = await getDocs(query(collection(db,"questions"), orderBy("createdAt","desc"), limit(200)));
        snap.forEach(d=> out.push({ id:d.id, ...d.data() }));
      }catch{
        const snap = await getDocs(collection(db,"questions"));
        snap.forEach(d=> out.push({ id:d.id, ...d.data() }));
        out.sort((a,b)=> (b.createdAt?.seconds||0)-(a.createdAt?.seconds||0));
      }

      const $list = document.getElementById("q_list");
      $list.innerHTML = out.map(q=>{
        const parts = getQuestionDirParts(q, false);
        const tags = Array.isArray(q.tags) ? q.tags : [];
        const en = q.enabled === true;

        const chips = parts.map(p=>{
          const d = dirDisplay(p.key);
          const col = d.color || "#aaa";
          const label = d.label || p.key;
          return `<span class="badge" style="border-color:${hexToRgba(col,.4)}; background:${hexToRgba(col,.12)}; color:#e9eefc">
            <b style="color:${col}">${htmlEscape(label)}</b> × <span class="mono">${Number(p.w).toFixed(2)}</span>
          </span>`;
        }).join(" ");

        return `
          <div class="item">
            <div class="top">
              <div style="flex:1">
                <div class="title">${htmlEscape(q.text)}</div>
                <div class="meta">
                  ${en ? `<span class="badge good">Enabled</span>` : `<span class="badge bad">Disabled</span>`}
                  <span class="badge">Direction mix:</span>
                  ${chips || `<span class="badge">${htmlEscape(q.direction || "—")}</span>`}
                  <span class="badge">Weight: <span class="mono">${Number(q.weight ?? 1).toFixed(2)}</span></span>
                  <span class="badge">By: <span class="mono">${htmlEscape(q.createdBy || "—")}</span></span>
                </div>
                ${tags.length ? `<div class="chips" style="margin-top:6px">${tags.map(t=>`<span class="chip">#${htmlEscape(t)}</span>`).join("")}</div>` : ``}
              </div>
              <div class="row">
                <button class="btn small ${en?'danger':'good'}" data-qtoggle="${q.id}" type="button">
                  ${en ? "Disable" : "Enable"}
                </button>
                <button class="btn small danger" data-qdelete="${q.id}" type="button">
                  Delete
                </button>
              </div>
            </div>
          </div>
        `;
      }).join("");

      $list.querySelectorAll("[data-qtoggle]").forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.getAttribute("data-qtoggle");
          const cur = out.find(x=>x.id===id);
          if(!cur) return;
          try{
            await updateDoc(doc(db,"questions", id), { enabled: !(cur.enabled===true) });
            toast("Updated.");
            await loadQuestions();
            await refreshQuestionList();
          }catch(e){
            toast("Failed: " + (e?.message || e));
          }
        };
      });

      $list.querySelectorAll("[data-qdelete]").forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.getAttribute("data-qdelete");
          const cur = out.find(x=>x.id===id);
          if(!cur) return;

          if(!confirm("Delete this question permanently?")) return;

          try{
            await deleteDoc(doc(db,"questions", id));
            toast("Deleted.");
            await loadQuestions();
            await refreshQuestionList();
          }catch(e){
            toast("Delete failed: " + (e?.message || e));
          }
        };
      });
    }

    document.getElementById("q_refresh").onclick = refreshQuestionList;

    document.getElementById("q_add").onclick = async ()=>{
      const text = document.getElementById("q_text").value.trim();
      const dirsSpec = document.getElementById("q_dirs").value.trim();
      const directions = parseDirectionSpec(dirsSpec);
      const weight = Number(document.getElementById("q_weight").value || 1);
      const tags = (document.getElementById("q_tags").value || "").split(",").map(t=>t.trim()).filter(Boolean);

      if(text.length < 8) return toast("Write a longer question.");
      if(!directions.length) return toast("Provide at least one valid direction (e.g. Right-wing or Right-wing:0.6, Centrist:0.4).");

      try{
        await addDoc(collection(db,"questions"), {
          text,
          directions,                    // NEW
          direction: directions[0].key,  // compatibility
          weight: clamp(weight, 0.05, 5),
          tags,
          enabled: true,
          createdBy: state.user.uid,
          createdAt: serverTimestamp()
        });
        toast("Question added.");
        document.getElementById("q_text").value = "";
        document.getElementById("q_tags").value = "";
        await loadQuestions();
        await refreshQuestionList();
      }catch(e){
        toast("Failed: " + (e?.message || e));
      }
    };

    await refreshQuestionList();
  }

  // ---- Router render ----
  async function render(){
    const r = route();
    const [p0, p1] = r.parts;

    if (state.user) {
      if (state.user.isAnonymous) {
        // Guest (not "logged in" for UI purposes)
        $userTag.textContent = `Guest · ${state.user.uid.slice(0,8)}…`;
        $authBtn.style.display = "inline-flex";
        $signOutBtn.style.display = "none";
      } else {
        // Logged-in (email/password)
        $userTag.textContent = `${state.user.displayName || "User"} · ${state.user.email || ""}`.trim();
        $authBtn.style.display = "none";
        $signOutBtn.style.display = "inline-flex";
      }
    } else {
      $userTag.textContent = "Connecting…";
      $authBtn.style.display = "inline-flex";
      $signOutBtn.style.display = "none";
    }

    $adminLink.style.display = state.isAdmin ? "inline-flex" : "none";

    if(p0 === "login") return showAuthModal();
    if(p0 === "quiz") return renderQuiz();
    if(p0 === "ledger") return renderLedger();
    if(p0 === "attempt" && p1) return renderAttemptPage(p1, false);
    if(p0 === "share" && p1) return renderAttemptPage(p1, true);
    if(p0 === "suggest") return renderSuggest();
    if(p0 === "admin") return renderAdmin();
    if(p0 === "compare") return renderCompare();
    return renderHome();
  }

  // ---- Boot & Guest auto-signin ----
  async function bootForUser(user){
    state.user = user;
    state.isAdmin = user ? await checkAdmin(user.uid) : false;

    await loadSettings();
    await loadQuestions();
    await render();
  }

  onAuthStateChanged(auth, async (user)=>{
    try{
      if(!user){
        await signInAnonymously(auth);
        return;
      }
      await bootForUser(user);
    }catch(e){
      toast("Auth error: " + (e?.message || e));
      state.user = null;
      state.isAdmin = false;
      await loadSettings();
      await loadQuestions();
      await render();
    }
  });

  window.addEventListener("hashchange", render);
  render();
</script>
</body>
</html>



